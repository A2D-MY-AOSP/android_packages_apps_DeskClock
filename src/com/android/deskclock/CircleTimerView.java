package com.android.deskclock;

import android.content.Context;
import android.content.res.Configuration;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Typeface;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.AttributeSet;
import android.view.View;
import android.widget.FrameLayout;

import com.android.deskclock.CircleTimerView.SavedState;

/**
 * TODO: Insert description here. (generated by isaackatz)
 */
public class CircleTimerView extends View {


    private final int mIdleColor = Color.WHITE;
    private final int mGoodColor = Color.GREEN;
    private final int mWarningColor = Color.YELLOW;
    private int mAlertColor;
    private long mIntervalTime = 0;
    private long mIntervalStartTime = -1;
    private long mCurrentIntervalTime = 0;
    private long mAccumulatedTime = 0;
    private boolean mPaused = false;
    private boolean mBlink = false;
    private String mTimeStr;
    private static float mTextSize = 96;
    private static float mStrokeSize = 4;
    private final Rect mTextBounds = new Rect();
    private final Paint mPaint = new Paint();
    private final Paint mTextPaint = new Paint();
    private final RectF mArcRect = new RectF();

    private boolean mShowTimeStr = true;
    // Class has 2 modes:
    // Timer mode - counting down. in this mode the animation is counter-clockwise and stops at 0
    // Stop watch mode - counting up - in this mode the animation is clockwise and will keep the
    //                   animation until stopped.
    private boolean mTimerMode = false; // default is stop watch view

    Runnable mAnimationThread = new Runnable() {

        @Override
        public void run() {
            mCurrentIntervalTime =
                    System.currentTimeMillis() - mIntervalStartTime + mAccumulatedTime;
            invalidate();
            postDelayed(mAnimationThread, 20);
        }

    };

    Runnable mBlinkThread = new Runnable() {

        @Override
        public void run() {
            mShowTimeStr = !mShowTimeStr;
            invalidate();
            postDelayed(mBlinkThread, 1000);
        }

    };


    public CircleTimerView(Context context) {
        super(context);
        init(context);
    }

    public void setTimeString(String t) {
        mTimeStr = t;
        invalidate();
    }

    public void setIntervalTime(long t) {
        mIntervalTime = t;
    }

    public void startIntervalAnimation() {
        mIntervalStartTime = System.currentTimeMillis();
        this.post(mAnimationThread);
        mPaused = false;
    }
    public void stopIntervalAnimation() {
        this.removeCallbacks(mAnimationThread);
        mIntervalStartTime = -1;
        mAccumulatedTime = 0;
    }

    public boolean isAnimating() {
        return (mIntervalStartTime != -1);
    }

    public void pauseIntervalAnimation() {
        this.removeCallbacks(mAnimationThread);
        mAccumulatedTime += System.currentTimeMillis() - mIntervalStartTime;
        mPaused = true;
    }

    public void blinkTimeStr(boolean blink) {
        mBlink = blink;
        if (blink) {
            postDelayed(mBlinkThread, 1000);
        } else {
            removeCallbacks(mBlinkThread);
            mShowTimeStr = true;
            invalidate();
        }
    }

    public CircleTimerView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    private void init(Context c) {
        mPaint.setColor(mIdleColor);
        mPaint.setAntiAlias(true);
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setStrokeWidth(mStrokeSize);

        mTextPaint.setColor(Color.WHITE);
        mTextPaint.setAntiAlias(true);
        mTextPaint.setTypeface(Typeface.DEFAULT_BOLD);
        mTextPaint.setTextSize(mTextSize);
        mTextPaint.setTextAlign(Paint.Align.CENTER);

        mAlertColor =  c.getResources().getColor(R.color.clock_red);

    }

    public void setTimerMode(boolean mode) {
        mTimerMode = mode;
    }

    public String getTimeString() {
        return mTimeStr;
    }

    @Override
    public void onDraw(Canvas canvas) {    	
        int xCenter = getWidth() / 2;
        int yCenter = getHeight() / 2;

 /*       if (mTimeStr != null && !mTimeStr.isEmpty() && mShowTimeStr) {
            mTextPaint.getTextBounds(mTimeStr, 0, mTimeStr.length(), mTextBounds);
            int textHeight = mTextBounds.bottom - mTextBounds.top;
            canvas.drawText(mTimeStr, xCenter, yCenter + textHeight / 2  + 1, mTextPaint);
        }
*/
        float radius = Math.min(xCenter, yCenter) - mStrokeSize;

        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
            xCenter = (int) (radius + mStrokeSize);
        }

        mPaint.setColor(mIdleColor);
        canvas.drawCircle (xCenter, yCenter, radius, mPaint);

        if (mIntervalStartTime != -1) {
            mArcRect.top = yCenter - radius;// - mStrokeSize; //height - radius;
            mArcRect.bottom = yCenter + radius;// + mStrokeSize; // + radius;
            mArcRect.left =  xCenter - radius;
            mArcRect.right = xCenter + radius;
            float percent = (float)mCurrentIntervalTime / (float)mIntervalTime;
    //        if (mTimerMode) {
                mPaint.setColor(mAlertColor);
      /*      } else {
                if (percent > 1) {
                    mPaint.setColor(mAlertColor);
                } else if (percent > 0.80) {
                    mPaint.setColor(mWarningColor);
                } else {
                    mPaint.setColor(mGoodColor);
                }
            }*/
            if (mTimerMode){
                canvas.drawArc (mArcRect, 270, - percent * 360 , false, mPaint);
            } else {
                canvas.drawArc (mArcRect, 270, + percent * 360 , false, mPaint);
            }
            mPaint.setStrokeWidth(mStrokeSize + 10);
            if (mTimerMode){
                canvas.drawArc (mArcRect, 265 - percent * 360, 10 , false, mPaint);
            } else {
                canvas.drawArc (mArcRect, 265 + percent * 360, 10 , false, mPaint);
            }
            mPaint.setStrokeWidth(mStrokeSize);
        }
    }

    @Override
    public Parcelable onSaveInstanceState() {
      Parcelable superState = super.onSaveInstanceState();
      SavedState ss = new SavedState(superState);

      ss.mIntervalTime = this.mIntervalTime;
      ss.mIntervalStartTime = this.mIntervalStartTime;
      ss.mCurrentIntervalTime = this.mCurrentIntervalTime;
      ss.mAccumulatedTime = this.mAccumulatedTime;
      ss.mPaused = this.mPaused;
      ss.mBlink = this.mBlink;
      ss.mTimerMode = this.mTimerMode;

      removeCallbacks(mBlinkThread);
      removeCallbacks(mAnimationThread);
      return ss;
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
      if(!(state instanceof SavedState)) {
        super.onRestoreInstanceState(state);
        return;
      }

      SavedState ss = (SavedState)state;
      super.onRestoreInstanceState(ss.getSuperState());

      this.mIntervalTime = ss.mIntervalTime;
      this.mIntervalStartTime = ss.mIntervalStartTime;
      this.mCurrentIntervalTime = ss.mCurrentIntervalTime;
      this.mAccumulatedTime = ss.mAccumulatedTime;
      this.mPaused = ss.mPaused;
      this.mTimerMode = ss.mTimerMode;
      if (mIntervalStartTime != -1 && !mPaused) {
          this.post(mAnimationThread);
      }
      this.mBlink = ss.mBlink;
      blinkTimeStr(mBlink);
    }

    static class SavedState extends BaseSavedState {
        public boolean mPaused = false;
        public long mIntervalTime = 0;
        public long mIntervalStartTime = -1;
        public long mCurrentIntervalTime = 0;
        public long mAccumulatedTime = 0;
        public boolean mBlink = false;
        public boolean mTimerMode;

        SavedState(Parcelable superState) {
            super(superState);
        }

        private SavedState(Parcel in) {
            super(in);
            this.mIntervalTime = in.readLong();
            this.mIntervalStartTime = in.readLong();
            this.mCurrentIntervalTime = in.readLong();
            this.mAccumulatedTime = in.readLong();
            this.mPaused = (in.readInt() == 1);
            this.mBlink = (in.readInt() == 1);
        }

        @Override
        public void writeToParcel(Parcel out, int flags) {
            super.writeToParcel(out, flags);
            out.writeLong(this.mIntervalTime);
            out.writeLong(this.mIntervalStartTime);
            out.writeLong(this.mCurrentIntervalTime);
            out.writeLong(this.mAccumulatedTime);
            out.writeInt(this.mPaused?1:0);
            out.writeInt(this.mBlink?1:0);
        }

        //required field that makes Parcelables from a Parcel
        public static final Parcelable.Creator<SavedState> CREATOR =
                new Parcelable.Creator<SavedState>() {
                    public SavedState createFromParcel(Parcel in) {
                        return new SavedState(in);
                    }
                    public SavedState[] newArray(int size) {
                        return new SavedState[size];
                    }
        };
    }

}
