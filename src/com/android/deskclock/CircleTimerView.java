package com.android.deskclock;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.RectF;
import android.graphics.Typeface;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.AttributeSet;
import android.view.View;

/**
 * TODO: Insert description here. (generated by isaackatz)
 */
public class CircleTimerView extends View {


    private int mRedColor;
    private int mWhiteColor;
    private long mIntervalTime = 0;
    private long mIntervalStartTime = -1;
    private long mMarkerTime = -1;
    private long mCurrentIntervalTime = 0;
    private long mAccumulatedTime = 0;
    private boolean mPaused = false;
    private static float mStrokeSize = 4;
    private final Paint mPaint = new Paint();
    private final RectF mArcRect = new RectF();
    private Resources mResources;

    // Class has 2 modes:
    // Timer mode - counting down. in this mode the animation is counter-clockwise and stops at 0
    // Stop watch mode - counting up - in this mode the animation is clockwise and will keep the
    //                   animation until stopped.
    private boolean mTimerMode = false; // default is stop watch view

    Runnable mAnimationThread = new Runnable() {

        @Override
        public void run() {
            mCurrentIntervalTime =
                    System.currentTimeMillis() - mIntervalStartTime + mAccumulatedTime;
            invalidate();
            postDelayed(mAnimationThread, 20);
        }

    };

    public CircleTimerView(Context context) {
        this(context, null);
    }

    public CircleTimerView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    public void setIntervalTime(long t) {
        mIntervalTime = t;
        postInvalidate();
    }

    public void setMarkerTime(long t) {
        mMarkerTime = mCurrentIntervalTime;
        postInvalidate();
    }

    public void reset() {
        mIntervalStartTime = -1;
        mMarkerTime = -1;
        postInvalidate();
    }
    public void startIntervalAnimation() {
        mIntervalStartTime = System.currentTimeMillis();
        this.post(mAnimationThread);
        mPaused = false;
    }
    public void stopIntervalAnimation() {
        this.removeCallbacks(mAnimationThread);
        mIntervalStartTime = -1;
        mAccumulatedTime = 0;
    }

    public boolean isAnimating() {
        return (mIntervalStartTime != -1);
    }

    public void pauseIntervalAnimation() {
        this.removeCallbacks(mAnimationThread);
        mAccumulatedTime += System.currentTimeMillis() - mIntervalStartTime;
        mPaused = true;
    }

    public void setPassedTime(long time) {
        mAccumulatedTime = time;
        postInvalidate();
    }



    private void init(Context c) {

        mResources = c.getResources();

        mPaint.setAntiAlias(true);
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setStrokeWidth(mStrokeSize);

        mWhiteColor = mResources.getColor(R.color.clock_white);
        mRedColor = mResources.getColor(R.color.clock_red);
    }

    public void setTimerMode(boolean mode) {
        mTimerMode = mode;
    }

    @Override
    public void onDraw(Canvas canvas) {
        int xCenter = getWidth() / 2 + 1;
        int yCenter = getHeight() / 2;

        mPaint.setStrokeWidth(mStrokeSize);
        float radius = Math.min(xCenter, yCenter) - mStrokeSize;

        if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
            xCenter = (int) (radius + mStrokeSize);
        }

        mPaint.setColor(mWhiteColor);
        canvas.drawCircle (xCenter, yCenter, radius, mPaint);

        mPaint.setColor(mRedColor);
        if (mIntervalStartTime != -1) {
            mArcRect.top = yCenter - radius;
            mArcRect.bottom = yCenter + radius;
            mArcRect.left =  xCenter - radius;
            mArcRect.right = xCenter + radius;
            float percent = (float)mCurrentIntervalTime / (float)mIntervalTime;
            // prevent timer from doing more than one full circle
            percent = (percent > 1 && mTimerMode) ? 1 : percent;

            if (mTimerMode){
                canvas.drawArc (mArcRect, 270, - percent * 360 , false, mPaint);
            } else {
                canvas.drawArc (mArcRect, 270, + percent * 360 , false, mPaint);
            }
            mPaint.setStrokeWidth(mStrokeSize + 10);
            if (mTimerMode){
                canvas.drawArc (mArcRect, 265 - percent * 360, 10 , false, mPaint);
            } else {
                canvas.drawArc (mArcRect, 265 + percent * 360, 10 , false, mPaint);
            }
         }
        if (mMarkerTime != -1) {
            mPaint.setStrokeWidth(mStrokeSize + 30);
            mPaint.setColor(mWhiteColor);
            float angle = (float)(mMarkerTime % mIntervalTime) / (float)mIntervalTime * 360;
            canvas.drawArc (mArcRect, 270 + angle, 1 , false, mPaint);
        }
    }

    private static final String PREF_CTV_PAUSED  = "_ctv_paused";
    private static final String PREF_CTV_INTERVAL  = "_ctv_interval";
    private static final String PREF_CTV_INTERVAL_START = "_ctv_interval_start";
    private static final String PREF_CTV_CURRENT_INTERVAL = "_ctv_current_interval";
    private static final String PREF_CTV_ACCUM_TIME = "_ctv_accum_time";
    private static final String PREF_CTV_TIMER_MODE = "_ctv_timer_mode";
    private static final String PREF_CTV_MARKER_TIME = "_ctv_marker_time";

    // Since this view is used in multiple places, use the key to save different instances
    public void writeToSharedPref(SharedPreferences prefs, String key) {
        SharedPreferences.Editor editor = prefs.edit();
        editor.putBoolean (key + PREF_CTV_PAUSED, mPaused);
        editor.putLong (key + PREF_CTV_INTERVAL, mIntervalTime);
        editor.putLong (key + PREF_CTV_INTERVAL_START, mIntervalStartTime);
        editor.putLong (key + PREF_CTV_CURRENT_INTERVAL, mCurrentIntervalTime);
        editor.putLong (key + PREF_CTV_ACCUM_TIME, mAccumulatedTime);
        editor.putLong (key + PREF_CTV_MARKER_TIME, mMarkerTime);
        editor.putBoolean (key + PREF_CTV_TIMER_MODE, mTimerMode);
        editor.apply();
    }

    public void readFromSharedPref(SharedPreferences prefs, String key) {
        mPaused = prefs.getBoolean(key + PREF_CTV_PAUSED, false);
        mIntervalTime = prefs.getLong(key + PREF_CTV_INTERVAL, 0);
        mIntervalStartTime = prefs.getLong(key + PREF_CTV_INTERVAL_START, 0);
        mCurrentIntervalTime = prefs.getLong(key + PREF_CTV_CURRENT_INTERVAL, 0);
        mAccumulatedTime = prefs.getLong(key + PREF_CTV_ACCUM_TIME, 0);
        mMarkerTime = prefs.getLong(key + PREF_CTV_MARKER_TIME, -1);
        mTimerMode = prefs.getBoolean(key + PREF_CTV_TIMER_MODE, false);
        if (mIntervalStartTime != -1 && !mPaused) {
            this.post(mAnimationThread);
        }
    }

}
