package com.android.deskclock;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.BaseAdapter;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.ListPopupWindow;
import android.widget.ListView;
import android.widget.PopupWindow.OnDismissListener;
import android.widget.TextView;

import com.android.deskclock.timer.TimerView;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;


/**
 * TODO: Insert description here. (generated by isaackatz)
 */
public class StopwatchFragment extends DeskClockFragment {

    // Stopwatch states
    private static final int STOPWATCH_RESET = 0;
    private static final int STOPWATCH_RUNNING = 1;
    private static final int STOPWATCH_STOPPED = 2;

    private static final int MAX_LAPS = 99;

    int mState = STOPWATCH_RESET;


    // Stopwatch views that are accessed by the activity
    private Button mLeftButton, mRightButton;
    private CircleTimerView mTime;
    private TimerView mTimeText;
    private View mLapsTitle;
    private ListView mLapsList;
    private Button mShareButton;
    private View mButtonSeperator;
    private ListPopupWindow mSharePopup;

    // Used for calculating the time from the start taking into account the pause times
    long mStartTime = 0;
    long mAccumulatedTime = 0;

    // Lap information
    class Lap {
        Lap () {
            mLapTime = 0;
            mTotalTime = 0;
        }

        Lap (long time, long total) {
            mLapTime = time;
            mTotalTime = total;
        }
        public long mLapTime;
        public long mTotalTime;
    }

    // Adapter for the ListView that shows the lap times.
    class LapsListAdapter extends BaseAdapter {

        ArrayList<Lap> mLaps = new ArrayList<Lap>();
        private final LayoutInflater mInflater;

        public LapsListAdapter(Context context) {
            mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        }

        @Override
        public long getItemId(int position) {
            return position;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            if (mLaps.size() == 0 || position >= mLaps.size()) {
                return null;
            }
            View lapInfo;
            if (convertView != null) {
                lapInfo = convertView;
            } else {
                lapInfo =  mInflater.inflate(R.layout.lap_view, parent, false);
            }
            TextView count = (TextView)lapInfo.findViewById(R.id.lap_number);
            TextView lapTime = (TextView)lapInfo.findViewById(R.id.lap_time);
            TextView toalTime = (TextView)lapInfo.findViewById(R.id.lap_total);
            lapTime.setText(getTimeText(mLaps.get(position).mLapTime));
            toalTime.setText(getTimeText(mLaps.get(position).mTotalTime));
            count.setText(getString(R.string.sw_current_lap_number, mLaps.size() - position));
            return lapInfo;

        }

        @Override
        public int getCount() {
            return mLaps.size();
        }

        @Override
        public Object getItem(int position) {
            if (mLaps.size() == 0 || position >= mLaps.size()) {
                return null;
            }
            return mLaps.get(position);
        }

        public void addLap(Lap l) {
            mLaps.add(0, l);
            notifyDataSetChanged();
        }

        public void clearLaps() {
            mLaps.clear();
            notifyDataSetChanged();
        }

        // Helper function used to get the lap data to be stored in the activitys's bundle
        public long [] getLapTimes() {
            int size = mLaps.size();
            if (size == 0) {
                return null;
            }
            long [] laps = new long[size];
            for (int i = 0; i < size; i ++) {
                laps[i] = mLaps.get(i).mLapTime;
            }
            return laps;
        }

        // Helper function to restore adapter's data from the activity's bundle
        public void setLapTimes(long [] laps) {
            if (laps == null || laps.length == 0) {
                return;
            }

            int size = laps.length;
            mLaps.clear();
            for (int i = 0; i < size; i ++) {
                mLaps.add(new Lap (laps[i], 0));
            }
            long totalTime = 0;
            for (int i = size -1; i >= 0; i --) {
                totalTime += laps[i];
                mLaps.get(i).mTotalTime = totalTime;
            }
            notifyDataSetChanged();
        }
    }

    // Since the stopwatch need to run even if the app is closed, save data to shared prefs.
    private static final String PREF_START_TIME  = "sw_start_time";
    private static final String PREF_ACCUM_TIME = "sw_accum_time";
    private static final String PREF_STATE = "sw_state";
    private static final String PREF_LAP_NUM = "sw_lap_num";
    private static final String PREF_LAP_TIME = "sw_lap_time_";


    // Keys for data stored in the activity's bundle
    private static final String START_TIME_KEY = "start_time";
    private static final String ACCUM_TIME_KEY = "accum_time";
    private static final String STATE_KEY = "state";
    private static final String LAPS_KEY = "laps";

    LapsListAdapter mLapsAdapter;

    public StopwatchFragment() {
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        View v = inflater.inflate(R.layout.stopwatch_fragment, container, false);
        mLeftButton = (Button)v.findViewById(R.id.stopwatch_left_button);
        mLeftButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                buttonClicked(true);
                switch (mState) {
                    case STOPWATCH_RUNNING:
                        // Save lap time
                        addLapTime(System.currentTimeMillis()/10);
                        showLaps();
                        setButtons(STOPWATCH_RUNNING);
                        break;
                    case STOPWATCH_STOPPED:
                        // do reset
                        SharedPreferences prefs =
                                PreferenceManager.getDefaultSharedPreferences(getActivity());
                        clearSharedPref(prefs);
                        mAccumulatedTime = 0;
                        mLapsAdapter.clearLaps();
                        showLaps();
                        mTime.stopIntervalAnimation();
                        mTime.reset();
                        mTimeText.setTime(mAccumulatedTime);
                        mTimeText.blinkTimeStr(false);
                        setButtons(STOPWATCH_RESET);
                        mState = STOPWATCH_RESET;
                        break;
                    default:
                        Log.wtf("Illegal state " + mState
                                + " while pressing the left stopwatch button");
                        break;
                }
            }
        });


        mRightButton = (Button)v.findViewById(R.id.stopwatch_right_button);
        mRightButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                buttonClicked(true);
                switch (mState) {
                    case STOPWATCH_RUNNING:
                        // do stop
                        stopUpdateThread();
                        mTime.pauseIntervalAnimation();
                        long curTime = System.currentTimeMillis()/10;
                        mAccumulatedTime += (curTime - mStartTime);
                        mTimeText.setTime(mAccumulatedTime);
                        mTimeText.blinkTimeStr(true);
                        updateCurrentLap(curTime, mAccumulatedTime);
                        setButtons(STOPWATCH_STOPPED);
                        mState = STOPWATCH_STOPPED;
                        break;
                    case STOPWATCH_RESET:
                    case STOPWATCH_STOPPED:
                        // do start
                        mStartTime = System.currentTimeMillis()/10;
                        startUpdateThread();
                        mTimeText.blinkTimeStr(false);
                        if (mTime.isAnimating()) {
                            mTime.startIntervalAnimation();
                        }
                        setButtons(STOPWATCH_RUNNING);
                        mState = STOPWATCH_RUNNING;
                        break;
                    default:
                        Log.wtf("Illegal state " + mState
                                + " while pressing the right stopwatch button");
                        break;
                }
            }
        });
        mShareButton = (Button)v.findViewById(R.id.stopwatch_share_button);
        mButtonSeperator = v.findViewById(R.id.stopwatch_button_seperator);

        mShareButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                showSharePopup();
            }
        });

        mTime = (CircleTimerView)v.findViewById(R.id.stopwatch_time);
        mTimeText = (TimerView)v.findViewById(R.id.stopwatch_time_text);
        mLapsTitle = v.findViewById(R.id.laps_title);
        mLapsList = (ListView)v.findViewById(R.id.laps_list);
        mLapsList.setDividerHeight(0);
        mLapsAdapter = new LapsListAdapter(getActivity());
        if (mLapsList != null) {
            mLapsList.setAdapter(mLapsAdapter);
        }

        return v;
    }

    @Override
    public void onResume() {
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getActivity());
        readFromSharedPref(prefs);
        mTime.readFromSharedPref(prefs, "sw");
        setButtons(mState);
        mTimeText.setTime(mAccumulatedTime);
        if (mState == STOPWATCH_RUNNING) {
            startUpdateThread();
        } else if (mState == STOPWATCH_STOPPED && mAccumulatedTime != 0) {
            mTimeText.blinkTimeStr(true);
        }
        showLaps();
        super.onResume();
    }

    @Override
    public void onPause() {
        if (mState == STOPWATCH_RUNNING) {
            stopUpdateThread();
        }
        // The stopwatch must keep running even if the user closes the app so save stopwatch state
        // in shared prefs
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getActivity());
        writeToSharedPref(prefs);
        mTime.writeToSharedPref(prefs, "sw");
        mTimeText.blinkTimeStr(false);
        if (mSharePopup != null) {
            mSharePopup.dismiss();
            mSharePopup = null;
        }

        super.onPause();
    }

    private void showShareButton(boolean show) {
        if (mShareButton != null) {
            mShareButton.setVisibility(show ? View.VISIBLE : View.GONE);
            mButtonSeperator.setVisibility(show ? View.VISIBLE : View.GONE);
            mShareButton.setEnabled(show);
        }
    }

    private void showSharePopup() {
        Intent intent = new Intent(android.content.Intent.ACTION_SEND);
        intent.setType("text/plain");
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        intent.putExtra(Intent.EXTRA_SUBJECT, getShareTitle());
        intent.putExtra(Intent.EXTRA_TEXT, buildShareResults());

        Activity parent = getActivity();
        PackageManager packageManager = parent.getPackageManager();

        // Get a list of sharable options.
        List<ResolveInfo> shareOptions = packageManager
                .queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);

        if (shareOptions.size() == 0) {
            return;
        }
        ArrayList<CharSequence> shareOptionTitles = new ArrayList<CharSequence>();
        ArrayList<Drawable> shareOptionIcons = new ArrayList<Drawable>();
        ArrayList<CharSequence> shareOptionThreeTitles = new ArrayList<CharSequence>();
        ArrayList<Drawable> shareOptionThreeIcons = new ArrayList<Drawable>();
        ArrayList<String> shareOptionPackageNames = new ArrayList<String>();
        ArrayList<String> shareOptionClassNames = new ArrayList<String>();

        for (int option_i = 0; option_i < shareOptions.size(); option_i++) {
            ResolveInfo option = shareOptions.get(option_i);
            CharSequence label = option.loadLabel(packageManager);
            Drawable icon = option.loadIcon(packageManager);
            shareOptionTitles.add(label);
            shareOptionIcons.add(icon);
            if (shareOptions.size() > 4 && option_i < 3) {
                shareOptionThreeTitles.add(label);
                shareOptionThreeIcons.add(icon);
            }
            shareOptionPackageNames.add(option.activityInfo.packageName);
            shareOptionClassNames.add(option.activityInfo.name);
        }
        if (shareOptionTitles.size() > 4) {
            shareOptionThreeTitles.add(getResources().getString(R.string.see_all));
            shareOptionThreeIcons.add(getResources().getDrawable(android.R.color.transparent));
        }

        if (mSharePopup != null) {
            mSharePopup.dismiss();
            mSharePopup = null;
        }
        mSharePopup = new ListPopupWindow(parent);
        mSharePopup.setAnchorView(mShareButton);
        mSharePopup.setModal(true);
        // This adapter to show the rest will be used to quickly repopulate if "See all..." is hit.
        ImageLabelAdapter showAllAdapter = new ImageLabelAdapter(parent,
                R.layout.popup_window_item, shareOptionTitles, shareOptionIcons,
                shareOptionPackageNames, shareOptionClassNames);
        if (shareOptionTitles.size() > 4) {
            mSharePopup.setAdapter(new ImageLabelAdapter(parent, R.layout.popup_window_item,
                    shareOptionThreeTitles, shareOptionThreeIcons, shareOptionPackageNames,
                    shareOptionClassNames, showAllAdapter));
        } else {
            mSharePopup.setAdapter(showAllAdapter);
        }

        mSharePopup.setOnItemClickListener(new OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                CharSequence label = ((TextView) view.findViewById(R.id.title)).getText();
                if (label.equals(getResources().getString(R.string.see_all))) {
                    mSharePopup.setAdapter(
                            ((ImageLabelAdapter) parent.getAdapter()).getShowAllAdapter());
                    mSharePopup.show();
                    return;
                }

                Intent intent = new Intent(Intent.ACTION_SEND);
                intent.setType("text/plain");
                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                intent.putExtra(Intent.EXTRA_SUBJECT, getShareTitle());
                intent.putExtra(Intent.EXTRA_TEXT, buildShareResults());
                ImageLabelAdapter adapter = (ImageLabelAdapter) parent.getAdapter();
                String packageName = adapter.getPackageName(position);
                String className = adapter.getClassName(position);
                intent.setClassName(packageName, className);
                startActivity(intent);
            }
        });
        mSharePopup.setOnDismissListener(new OnDismissListener() {
            @Override
            public void onDismiss() {
                mSharePopup = null;
            }
        });
        mSharePopup.setWidth((int) getResources().getDimension(R.dimen.popup_window_width));
        mSharePopup.show();
    }

    /***
     * Update the buttons on the stopwatch according to the watch's state
     */
    private void setButtons(int state) {
        switch (state) {
            case STOPWATCH_RESET:
                setButton(mLeftButton, R.string.sw_lap_button, false, View.INVISIBLE);
                setButton(mRightButton, R.string.sw_start_button, true, View.VISIBLE);
                showShareButton(false);
                break;
            case STOPWATCH_RUNNING:
                setButton(mLeftButton, R.string.sw_lap_button, !reachedMaxLaps(), View.VISIBLE);
                setButton(mRightButton, R.string.sw_stop_button, true, View.VISIBLE);
                showShareButton(false);
                break;
            case STOPWATCH_STOPPED:
                setButton(mLeftButton, R.string.sw_reset_button, true, View.VISIBLE);
                setButton(mRightButton, R.string.sw_start_button, true, View.VISIBLE);
                showShareButton(true);
                break;
            default:
                break;
        }
    }
    private boolean reachedMaxLaps() {
        return mLapsAdapter.getCount() >= MAX_LAPS;
    }

    /***
     * Set a single button with the string and states provided.
     * @param b - Button view to update
     * @param text - Text in button
     * @param enabled - enable/disables the button
     * @param visibility - Show/hide the button
     */
    private void setButton (Button b, int text, boolean enabled, int visibility) {
        b.setText(text);
        b.setVisibility(visibility);
        b.setEnabled(enabled);
    }

    /***
     * Sets the string of the time running on the stopwatch up to hundred of a second accuracy
     * @param time - in hundreds of a second since the stopwatch started
     */
    private String getTimeText(long time) {
        if (time < 0) {
            time = 0;
        }
        long hundreds, seconds, minutes, hours;
        seconds = time / 100;
        hundreds = (time - seconds * 100);
        minutes = seconds / 60;
        seconds = seconds - minutes * 60;
        hours = minutes / 60;
        minutes = minutes - hours * 60;
        if (hours > 99) {
            hours = 0;
        }
        // TODO: must build to account for localization
        String timeStr;
        if (hours >= 10) {
            timeStr = String.format("%02dh %02dm %02ds .%02d", hours, minutes, seconds, hundreds);
        } else if (hours > 0) {
            timeStr = String.format("%01dh %02dm %02ds .%02d", hours, minutes, seconds, hundreds);
        } else if (minutes >= 10) {
            timeStr = String.format("%02dm %02ds .%02d", minutes, seconds, hundreds);
        } else {
            timeStr = String.format("%02dm %02ds .%02d", minutes, seconds, hundreds);
        }
        return timeStr;
    }

    /***
     *
     * @param time - in hundredths of a second
     */
    private void addLapTime(long time) {
        int size = mLapsAdapter.getCount();
        long curTime = time - mStartTime + mAccumulatedTime;
        if (size == 0) {
            // Always show the ending lap and a new one
            mLapsAdapter.addLap(new Lap(curTime, curTime));
            mLapsAdapter.addLap(new Lap(0, curTime));
            mTime.setIntervalTime(curTime * 10);
        } else {
            long lapTime = curTime - ((Lap) mLapsAdapter.getItem(1)).mTotalTime;
            ((Lap)mLapsAdapter.getItem(0)).mLapTime = lapTime;
            ((Lap)mLapsAdapter.getItem(0)).mTotalTime = curTime;
            mLapsAdapter.addLap(new Lap(0, 0));
            mTime.setMarkerTime(lapTime * 10);
        //    mTime.setIntervalTime(lapTime * 10);
        }
        mLapsAdapter.notifyDataSetChanged();
        // Start lap animation starting from the second lap
         mTime.stopIntervalAnimation();
         if (!reachedMaxLaps()) {
             mTime.startIntervalAnimation();
         }
    }

    private void updateCurrentLap(long curTime, long totalTime) {
        if (mLapsAdapter.getCount() > 0) {
            Lap curLap = (Lap)mLapsAdapter.getItem(0);
            curLap.mLapTime = totalTime - ((Lap)mLapsAdapter.getItem(1)).mTotalTime;
            curLap.mTotalTime = totalTime;
            mLapsAdapter.notifyDataSetChanged();
        }
    }

    private void showLaps() {
        if (mLapsAdapter.getCount() > 0) {
            mLapsList.setVisibility(View.VISIBLE);
            mLapsTitle.setVisibility(View.VISIBLE);
        } else {
            mLapsList.setVisibility(View.INVISIBLE);
            mLapsTitle.setVisibility(View.INVISIBLE);
        }
    }

    private void startUpdateThread() {
        mTime.post(mTimeUpdateThread);
    }

    private void stopUpdateThread() {
        mTime.removeCallbacks(mTimeUpdateThread);
    }

    Runnable mTimeUpdateThread = new Runnable() {
        @Override
        public void run() {
            long curTime = System.currentTimeMillis()/10;
            long totalTime = mAccumulatedTime + (curTime - mStartTime);
            if (mTime != null) {
                mTimeText.setTime(totalTime);
            }
            if (mLapsAdapter.getCount() > 0) {
                updateCurrentLap(curTime, totalTime);
            }
            mTime.postDelayed(mTimeUpdateThread, 10);
        }
    };

    private String getShareTitle() {
        String [] mLabels = getActivity().getResources().getStringArray(R.array.sw_share_strings);
        return mLabels[(int)(Math.random() * mLabels.length)];
    }
    private String buildShareResults() {
        String results = getString(R.string.sw_share_main, mTimeText.getTimeString() + "\n");
        int lapsNum = mLapsAdapter.getCount();
        if (lapsNum == 0) {
            return results;
        }
        results += getString(R.string.sw_share_laps) + "\n";
        for (int i = 1; i <= lapsNum; i ++) {
            results += String.format(
                    "%d. %s\n", i, getTimeText(((Lap) mLapsAdapter.getItem(lapsNum - i)).mLapTime));
        }
        return results;
    }

    private void writeToSharedPref(SharedPreferences prefs) {
        SharedPreferences.Editor editor = prefs.edit();
        editor.putLong (PREF_START_TIME, mStartTime);
        editor.putLong (PREF_ACCUM_TIME, mAccumulatedTime);
        editor.putInt (PREF_STATE, mState);
        if (mLapsAdapter != null) {
            long [] laps = mLapsAdapter.getLapTimes();
            if (laps != null) {
                editor.putInt (PREF_LAP_NUM, laps.length);
                for (int i = 0; i < laps.length; i++) {
                    String key = PREF_LAP_TIME + Integer.toString(i);
                    editor.putLong (key, laps[i]);
                }
            }
        }
        editor.apply();
    }

    private void readFromSharedPref(SharedPreferences prefs) {
        mStartTime = prefs.getLong(PREF_START_TIME, 0);
        mAccumulatedTime = prefs.getLong(PREF_ACCUM_TIME, 0);
        mState = prefs.getInt(PREF_STATE, STOPWATCH_RESET);
        if (mLapsAdapter != null) {
            int lapNum = prefs.getInt(PREF_LAP_NUM, STOPWATCH_RESET);
            long[] laps = new long[lapNum];
            for (int i = 0; i < lapNum; i++) {
                String key = PREF_LAP_TIME + Integer.toString(i);
                laps[i] = prefs.getLong(key, 0);
            }
            mLapsAdapter.setLapTimes(laps);
        }
    }

    private void clearSharedPref(SharedPreferences prefs) {
        SharedPreferences.Editor editor = prefs.edit();
        editor.remove (PREF_START_TIME);
        editor.remove (PREF_ACCUM_TIME);
        editor.remove (PREF_STATE);
        int lapNum = prefs.getInt(PREF_LAP_NUM, STOPWATCH_RESET);
        for (int i = 0; i < lapNum; i++) {
            String key = PREF_LAP_TIME + Integer.toString(i);
            editor.remove(key);
        }
        editor.remove(PREF_LAP_NUM);
        editor.apply();
    }

    public class ImageLabelAdapter extends ArrayAdapter<CharSequence> {
        private final ArrayList<CharSequence> mStrings;
        private final ArrayList<Drawable> mDrawables;
        private final ArrayList<String> mPackageNames;
        private final ArrayList<String> mClassNames;
        private ImageLabelAdapter mShowAllAdapter;

        public ImageLabelAdapter(Context context, int textViewResourceId,
                ArrayList<CharSequence> strings, ArrayList<Drawable> drawables,
                ArrayList<String> packageNames, ArrayList<String> classNames) {
            super(context, textViewResourceId, strings);
            mStrings = strings;
            mDrawables = drawables;
            mPackageNames = packageNames;
            mClassNames = classNames;
        }

        // Use this constructor if showing a "see all" option, to pass in the adapter
        // that will be needed to quickly show all the remaining options.
        public ImageLabelAdapter(Context context, int textViewResourceId,
                ArrayList<CharSequence> strings, ArrayList<Drawable> drawables,
                ArrayList<String> packageNames, ArrayList<String> classNames,
                ImageLabelAdapter showAllAdapter) {
            super(context, textViewResourceId, strings);
            mStrings = strings;
            mDrawables = drawables;
            mPackageNames = packageNames;
            mClassNames = classNames;
            mShowAllAdapter = showAllAdapter;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            LayoutInflater li = getActivity().getLayoutInflater();
            View row = li.inflate(R.layout.popup_window_item, parent, false);
            ((TextView) row.findViewById(R.id.title)).setText(
                    mStrings.get(position));
            ((ImageView) row.findViewById(R.id.icon)).setBackground(
                    mDrawables.get(position));
            return row;
        }

        public String getPackageName(int position) {
            return mPackageNames.get(position);
        }

        public String getClassName(int position) {
            return mClassNames.get(position);
        }

        public ImageLabelAdapter getShowAllAdapter() {
            return mShowAllAdapter;
        }
    }
}
